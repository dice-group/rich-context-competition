{
    "abstract": "Abstract\nA Monte Carlo simulation study is an essential tool for evaluating the behavior of various quantitative methods including\nstructural equation modeling (SEM) under various conditions. Typically, a large number of replications are recommended for\na Monte Carlo simulation study, and therefore automating a Monte Carlo simulation study is important to get the desired\nnumber of replications for a simulation study. This article is intended to provide concrete examples for automating a Monte\nCarlo simulation study using some standard software packages for SEM: Mplus, LISREL, SAS PROC CALIS, and R package\nlavaan. Also, the equivalence between the multilevel SEM and hierarchical linear modeling (HLM) is discussed, and relevant\nexamples are provided. It is hoped that the codes in this article can provide some building blocks for researchers to write\ntheir own code to automate simulation procedures.\n",
    "reduced_content": "sgo.sagepub.com\nCreative Commons CC BY: This article is distributed under the terms of the Creative Commons Attribution 3.0 License\n(http://www.creativecommons.org/licenses/by/3.0/) which permits any use, reproduction and distribution of the work without further\npermission provided the original work is attributed as specified on the SAGE and Open Access page (http://www.uk.sagepub.com/aboutus/openaccess.htm).\nArticle\nIntroduction\nEvaluating the behavior of estimators under various conditions\nis important to ensure the validity of inferences based on struc-\ntural equation modeling (SEM). For example, the violation of\nthe multivariate normality assumption (Finney & DiStefano,\ncould be investigated by evaluating the behavior of estimators\nunder those specific conditions. Analytic solutions to those\nquestions could be obtained under some ideal assumptions\nsuch as large sample sizes in asymptotic theory. However, ana-\nlytic solutions are not always tractable especially when the con-\nditions of interest become more realistic (small sample size,\nnon-normality, etc.). A Monte Carlo simulation study is a use-\nful alternative for evaluating the behavior of estimators when\nanalytic solutions are not available.\nA Monte Carlo simulation study is a computer-intensive\nprocedure in which random numbers are used to get empirical\nsampling distributions of estimators under conditions of inter-\nest (Bandalos, 2006). In a Monte Carlo simulation study, a\nlarge number of samples are replicated based on known popu-\nlation parameter values, and empirical sampling distributions\nare obtained from the set of estimates calculated across repli-\ncated samples. The empirical sampling distributions can be\nused to evaluate the behavior of estimators in terms of bias,\nroot mean square error, coverage rate, and so on.\nThe procedures of a Monte Carlo simulation study can be\nconceptualized into design and implementation stages (Paxton,\nCurran, Bollen, Kirby, & Chen, 2001). In a design stage, simu-\nlation conditions such as the number of replications, distribu-\ntions of variables, and methods for estimation are chosen\nbased on research questions. Given simulation conditions, a\nMonte Carlo simulation study is implemented using a specific\nsoftware package to estimate parameters of the model of inter-\nest. A large number of replications are typically recommended\nfor a Monte Carlo simulation study, and therefore automating\na Monte Carlo simulation study is essential to get the desired\nnumber of replications for a simulation study.\nThis article was intended to provide concrete examples of\nautomating a Monte Carlo simulation study using some stan-\ndard software packages for SEM. To do so, the capabilities of\na Monte Carlo simulation study in various SEM software\npackages were demonstrated using the example of a simple\nconfirmatory factor analysis (CFA) with two factors. Also, as\nan extension of the standard SEM, a multilevel SEM was\ncompared with hierarchical linear modeling (HLM), and rel-\nevant examples were also provided. More specifically, this\nwork is guided by three goals: (a) to review built-in Monte\nCarlo simulation capabilities in Mplus (L. K. Muth\u00e9n &\n1University of Georgia, Athens, USA\nCorresponding Author:\nSunbok Lee, Center for Family Research, University of Georgia, 1095\nEmail: sunboklee@gmail.com\nImplementing a Simulation Study Using\nMultiple Software Packages for Structural\nEquation Modeling\nSunbok Lee1\n Keywords\nMonte Carlo simulation, automation.\n2 SAGE Open\nand SAS PROC CALIS (SAS Institute, Cary NC); (b) to\nreview R package simsem (Pornprasertmanit, Miller, &\nSchoemann, 2013) that can be used to automate a Monte\nCarlo simulation using R package lavaan (Rosseel, 2012);\nand (c) to demonstrate how simulation procedures can be\nautomated using the R software package (R Core Team,\n2012) when software packages such as HLMwin\n(Raudenbush, Bryk, & Congdon, 2004) do not provide capa-\nbilities for a Monte Carlo simulation. For a simulation using\nHLMwin, some built-in R functions that can be used to auto-\nmate simulation procedures were introduced so that research-\ners can use those building blocks to write their own code.\nEspecially, some R functions that support the regular expres-\nsion, which will be explained later, are useful tools for\nextracting statistics of interest from output files. Example\ncodes for a Monte Carlo simulation study using each soft-\nware package are provided in Appendices A to E.\nMonte Carlo Simulation Studies in SEM\nTo do Monte Carlo simulation studies, several factors need to\nbe considered in the design and implementation stages. For\nexample, the number of replications in a Monte Carlo simu-\nlation study, which corresponds to the sample size in applied\nresearch, is directly related to the sampling variance of esti-\nmated parameters. Hence, the number of replications needs\nto be chosen based on the accuracy required by the purpose\nof the simulation study (Cohen, Kane, & Kim, 2001; Harwell,\nStone, Hsu, & Kirisci, 1996). Also, the values of population\nparameters need to be chosen to reflect conditions commonly\nencountered in applied research studies (Paxton et al., 2001).\nThe guidelines for a Monte Carlo simulation study in general\nare well documented in previous literature (Bandalos, 2006;\nHarwell et al., 1996). In this article, the focus is given on\nhow to implement or automate a Monte Carlo simulation\nstudy using standard software packages for SEM.\nVarious traditional software packages are available for the\nestimation in SEM. Comparisons of such software packages\nresearchers to choose software packages appropriate for their\nanalytic goals. In this article, four software packages--\n(J\u00f6reskog & S\u00f6rbom, 2006), R package lavaan (Rosseel,\nNC, USA)--were chosen to demonstrate actual implementa-\ntions of a Monte Carlo simulation study in SEM. Also, SEM\nis flexible enough to model multilevel data structure, and it is\nwell known that multilevel SEM is equivalent to HLM (Hox,\ncan automate a Monte Carlo simulation study using HLMwin\nwas also provided and explained, which could be useful in\nconducting a Monte Carlo simulation study comparing mul-\ntilevel SEM and HLM. The relevant R functions that were\nused to automate a Monte Carlo simulation study using\nHLMwin could be useful in automating a Monte Carlo simu-\nlation study using other software packages that do not have\nbuilt-in Monte Carlo capabilities.\nFor Mplus, LISREL, and PROC CALIS, built-in capabili-\nties for Monte Carlo simulations are reviewed, with the\nemphasis on doing simulations using data sets that are gener-\nated outside those software packages. Often, researchers pre-\nfer to use their own code in generating data sets to precisely\ncontrol the data generation mechanism. In Mplus, LISREL,\nand PROC CALIS, Monte Carlo simulation studies can be\nperformed using external data sets that are generated by\nresearchers'own codes as well as the data sets that are gener-\nated by those software packages themselves. On the other\nhand, R package simsem is used to facilitate a simulation\nstudy using the R package lavaan. Moreover, the R package\nsimsem can also be used to generate data sets for a simula-\ntion study using Mplus and LISREL. For HLMwin, the R\ncode that automates simulation procedures for writing input\ncommand files, running HLMwin, and extracting statistics\nfrom output files is provided.\nA Simulation Study Using Mplus\nMplus.Mplus provides comprehensive capabilities for a\nMonte Carlo simulation study. One way of doing a simula-\ntion study using Mplus is to analyze data sets that are gener-\nated by Mplus itself. In Mplus, data sets for a simulation can\nbe generated based on the population parameters specified in\nthe MODEL POPULATION command and analyzed based\non the model specified in the MODEL command. In the\nMODEL POPULATION command, population parameters\ncan be fixed to a specific number or freed to be estimated\nusing the @ or * symbol, respectively, followed by numbers\nrepresenting the values of population parameters. The results\nof simulations are presented using summary statistics such as\nthe average and standard deviation of parameter estimates,\naverage of the estimated standard errors, mean square error\nfor each parameter, and coverage rate of 95% confidence\nintervals.\nOften, researchers prefer to generate data sets using their\nown code to control the details of the data generation mecha-\nnism. In Mplus, external data files can be used to perform a\nMonte Carlo simulation study. To use external data files, the\ntext file specified in the FILE option of the DATA command\nneeds to contain a list of file names of the external data files\nand the TYPE = MONTECARLO option should be used in\nthe DATA command.\nOn the other hand, Mplus can be used as a data generator\nfor Monte Carlo simulation studies using other software\npackages. Using the REPSAVE and SAVE options in the\nMONTECARLO command, the data sets generated by the\nMODEL POPULATION command can be saved as text files.\nFor example, REPSAVE = ALL and SAVE = sim*.dat\noptions can be used to save data files for all replications with\nthe file names, sim1.dat, sim2.dat, and so on. The list of data\nfile names are automatically saved in the file named simlist.\ndat. Those generated data files can be used for a Monte Carlo\nsimulation study using other software packages.\nExample codes for a simulation using Mplus.In the Mplus\ncodes in Appendix A1, data sets for a simulation are gener-\nated using Mplus itself. A simple CFA with two factors is\nspecified in the MODEL POPULATION command. The fac-\ntor loadings are set to be freely estimated using * symbol and\nthe variances are set to be fixed to specific values using the\n@ symbol. The values of parameters in the MODEL com-\nmand are used as starting values in estimating parameters or\nas population parameters in calculating coverage rates. By\nusing the REPSAVE and SAVE options in the MONTE-\nCARLO command, data sets for all the replications are saved\nas text files named sim1.dat, sim2.dat, and so on.\nIn the Mplus code in Appendix A2, it is assumed that data\nsets for a simulation are generated outside Mplus. For this\nexample, data files are created using the R package simsem\nas presented in Appendix C. In the simsem package, a user\ncan specify a model for data generation and the generated\ndata sets can be exported to text files using the exportData()\nfunction. The current version of the simsem package sup-\nports exporting data files for both Mplus and LISREL.\nBecause the character string for the fileStem option in the\nexportData() function is specified as \"simMplus,\" the names\nof data files created by the exportData() function are simMp-\nlus1.dat, simMplus2.dat, and so on, and the file named\nsimMplus.dat contains a list of data file names. In Mplus, to\ndo a Monte Carlo simulation using external data files, a file\nthat contains a list of external data file names needs to be\nspecified in the FILE option of the DATA command. By run-\nning the Mplus code in Appendix A2, Mplus fits the model\nspecified in the MODEL command to data files listed in the\ndata.dat and provides summary statistics for the simulation\nresults.\nA Simulation Study Using R Package lavaan\nThe R package lavaan, which stands for a latent variable\nanalysis, is developed for a latent variable modeling in R.\nThis package is still under development, adding new fea-\ntures. For a simulation study using lavaan, researchers can\nwrite their own R code from scratch. In that way, researchers\ncan have more control over simulation procedures, espe-\ncially for the data generation part. The structure of a code for\na simulation using lavaan would be similar to the one using\nHLM in the previous section in that both codes need to gen-\nerate data sets, repeatedly run software packages to estimate\nparameters for each replication, and summarize results\nacross replications. However, the whole simulation proce-\ndures can be more easily connected in the case of lavaan\nbecause all the intermediate results such as generated data\nsets or estimated parameters are saved as variables in R. In\nthat case, connecting simulation procedures is just a matter\nof referring variables within R. In contrast, in the case of\nHLM, additional efforts need to be given to writing input\ncommand files or extracting statistics from output text files.\nIn this article, instead of writing R code from scratch, the\nR package simsem is used to do a simulation using lavaan.\nSome built-in functions in the package simsem can be used\nto generate data sets for a simulation, to run lavaan to esti-\nmate parameters, and to summarize estimated parameters\nacross replications. By using those built-in functions, R code\nfor a simulation study using lavaan can be greatly simplified\ncompared with the one written from scratch.\nSome built-in functions in the package simsem. In the R pack-\nage simsem, three built-in functions are essential to imple-\nment a simulation study using lavaan: the bind(), model(),\nand sim() function. First, the bind() function creates simMa-\ntrix objects that represent various matrices in SEM using\nLISREL-style notation. For example, LY, PS, and TE sym-\nbols represent factor loading matrix, residual variance\u00ad\ncovariance matrix among endogenous factors, and measure-\nment error variance\u00adcovariance matrix among indicators,\nrespectively. A simMatrix object contains information on the\nparameter specifications of a model such as freed, fixed, or\nconstrained parameters: Any parameter specified by the\nstring NA is a free parameter to be estimated and the param-\neters represented by the same character are constrained to be\nequal. The simMatrix objects created by the bind() function\nare combined to build templates, which are simSem objects,\nfor data generation and analysis using the model() function.\nGiven the templates, an actual Monte Carlo simulation study\ncan be performed using the sim() function that can generate\ndata sets, analyze data sets using lavaan, and summarize\nresults across replications at the same time. The implementa-\ntion of a Monte Carlo simulation study using lavaan can be\ngreatly simplified by using the bind(), model(), and sim()\nfunction in the R package simsem.\nLike Mplus, the R package simsem can also be used as a\ndata generator for a simulation study using other software\npackages. The data sets generated in the package simsem can\nbe exported to text files using the exportData() function. In\nthe current version, the exportData() function exports data\nsets to text files that can be analyzed by either Mplus or\nExample codes for a simulation using the package simsem.R\ncodes for a simulation using the package simsem are pre-\nsented in Appendix C. A simple CFA model with two factors\nwas used for this example. First, to represent six indicators\nmeasuring two factors, a six-by-two matrix named \"loading\"\nwas created to define a matrix for factor loadings. As each\nfactor was measured by three indicators, three NAs were\nassigned to each column to indicate free parameters to be\nestimated. The values of population factor loadings were\ndefined using a separate matrix named \"loadingValues.\" The\nbind() function was used to create simMatrix object LY using\n4 SAGE Open\nthose matrices. The simMatrix objects PS and TE, which\nrepresent residual variance\u00adcovariance matrix among endog-\nenous factors, and measurement error variance\u00adcovariance\nmatrix among indicators, respectively, were also created in a\nsimilar way. Those simMatrix objects are passed to the func-\ntion model() to create templates, which is a simSem object,\nfor data generation and analysis. Given the simSem object, a\nMonte Carlo simulation can be easily done using the func-\ntion sim(). Also, data files for a simulation using other soft-\nware packages can be created using the function\nexportData().\nA Simulation Study Using LISREL\nLike Mplus, external data files can be used to perform a\nMonte Carlo simulation using LISREL. For a simulation\nusing external data files, LISREL can be run in batch mode\nusing a DOS batch file as shown in Gagne and Furlow (2009)\nor using the shell() function in R as shown in the simulation\nstudy for HLM in the previous section. In this article, the\nbuilt-in RP command in LISREL is used to do a simulation\nstudy using LISREL. With the RP command, LISREL fits a\nmodel to multiple data sets in a single data file and reports\nmultiple results in a single output file. The RP command is\nused to specify the number of multiple data sets or replica-\ntions within a single data file. With PV option in OU com-\nmand, all estimated parameters will be saved in a text file.\nFor data generation, researchers' own code or some software\npackages such as Mplus or R package simsem can be used.\nAs mentioned in the previous section, the R package simsem\nis capable of exporting data sets that can be directly analyzed\nby LISREL using the RP command. In this article, the data\nsets for a simulation using LISREL in Appendix D are cre-\nated using the R package simsem in Appendix C.\nA Simulation Study Using SAS PROC CALIS\nPROC CALIS is a procedure for doing SEM in SAS. As SAS\nprovides programming capabilities, whole simulation proce-\ndures, including generating data sets, running PROC CALIS,\nand summarizing results, can be implemented within SAS as\nshown in Fan and Fan (2005). In their work, a do-loop state-\nment was used to run PROC CALIS repeatedly. In this arti-\ncle, the BY and ODS (Output Delivery System) statement in\nPROC CALIS are used to do a Monte Carlo simulation with-\nout using a do-loop statement, which makes the code more\nsimple.\nWith the BY statement, PROC CALIS performs separate\nanalyses on observations in groups defined by the variables\nin the BY statement. Therefore, using the BY statement,\nanalyses across all replications can be done at one time with-\nout using a do-loop statement when data sets for all replica-\ntions are combined into one data set including a group\nvariable representing replications. On the other hand, the\nODS output statement can be used to create SAS data sets\nfrom internal ODS tables containing parameter estimates, fit\nstatistics, and so on. The names of available ODS tables can\nbe checked in the PROC CALIS manual. Combined with the\nBY statement, the ODS statement creates SAS data sets that\ncontain results of PROC CALIS across all replications.\nExample code for a simulation using PROC CALIS.Example\ncodes for a simulation using PROC CALIS are presented in\nAppendix E. In this example, data files for a simulation are\ngenerated by Mplus using the code presented in Appendix\nA1.As Mplus creates a separate data file for each replication,\nthe R code in Appendix E1 is used to combine data files into\none data file, including a group variable representing replica-\ntions. Using the SAS code in Appendix E2, the combined\ndata file is imported into SAS, sorted by the variable repre-\nsenting replications, and fitted to a model. With the BY state-\nment, a separate analysis is done for each replication without\nusing a do-loop statement. The parameter estimates across\nall replications are saved into the SAS data set using the ODS\nstatements.\nSEM and HLM have been developed for different purposes.\nSEM was developed to model means and covariance struc-\ntures among multivariate data, whereas HLM was developed\nto model clustered data. One of the key differences between\nSEM and HLM is the assumption about the independence of\nobservations: SEM assumes the independence of observa-\ntions, whereas HLM attempts to explicitly model the depen-\ndency in data structure (Curran, 2003). However, it turned\nout that HLM can be incorporated into conventional SEM.\nThe key to understand how HLM can be modeled using con-\nventional SEM is to recognize that univariate multilevel\nmodels are actually multivariate unilevel models (Mehta &\nNeale, 2005). That is, the variability between clusters in\nHLM is captured by the common factor in SEM, and the\nvariability within clusters in HLM is captured by the unique\nfactor in SEM. Because the number of subjects within a clus-\nter can vary across clusters, fitting HLM in conventional\nSEM framework requires maximizing the likelihood func-\ntion represented as the sum of individual likelihood func-\ntions. Therefore, HLM can be specified in any SEM software\npackage supporting full information maximum likelihood\n(FIML) estimation (Hox, 2013). Recent versions of SEM\nsoftware packages have special commands to handle compli-\ncated set-ups for implementing HLM.\nEven though HLM can be incorporated into conventional\nSEM software packages, it is still necessary to conduct a\nMonte Carlo simulation study using conventional HLM soft-\nware packages such as HLMwin (Raudenbush et al., 2004)\nbecause HLM has its unique characteristics such as its capa-\nbility of modeling higher level models or its flexibility of\nhandling continuous time predictor (Hox, 2013). Unlike\nother SEM software packages presented in this article,\nhowever, HLMwin does not provide built-in capabilities for\na Monte Carlo simulation study. In the following section, it is\ndemonstrated how to use the R software package to automate\na Monte Carlo simulation study using HLMwin. The R func-\ntions introduced here would be useful for conducting a\nMonte Carlo simulation study using any software package\nthat does not provide built-in capabilities for a Monte Carlo\nsimulation study.\nA Simulation Study Using HLMwin\nSome standard software packages, such as HLMwin, SAS\nPROC MIXED, and R package lme4, are available to fit\nmodels in HLM. As SAS and R provide versatile program-\nming capabilities, simulation procedures can be easily inter-\nconnected within SAS PROC MIXED or R package lme4.\nFor example, data sets can be generated using R code and\nsaved as objects within R. The generated data sets or R\nobjects can be easily passed to the functions in the package\nlme4 to get parameter estimates, which can also be easily\nsummarized within R. In such a case, connecting simulation\nprocedures is just a matter of referring variables within the\nsame programming environment. However, doing a simula-\ntion study using a stand-alone software such as HLM poses\nmore practical problems in implementing a simulation if the\nstand-alone software does not provide capabilities for a\nMonte Carlo simulation. In such a case, some additional pro-\ngramming skills are required to automate a simulation: First,\nbefore running a software to get the desired number of repli-\ncations, a large number of data and input command files need\nto be prepared. In doing so, file names or some commands in\ninput command files need to be changed automatically from\nreplication to replication. Second, a stand-alone software\nneeds to be run repeatedly with different data and input com-\nmand files from replication to replication. Third, given a\nlarge number of output files, statistics of interest need to be\nextracted from output files to summarize results. The afore-\nmentioned skills can be implemented using some built-in R\nfunctions, which are introduced in the remaining part of this\nsection.\nManipulating character strings in R. The paste() function in R\ncan be used to change file names and some input commands\nfrom replication to replication. Basically, the paste() function\ncombines several arguments to form a combined string. For\nexample, the paste() function in the example below com-\nbines the string \"Level1rep,\" the value stored in the variable\nnamed files, and the string \".dat\" to form a combined string.\nIf the variable named files has value of 1, the combined\nstring assigned to filename1 becomes \"Level1rep1.dat.\"\n>filename1 <- paste(\"Level1rep\", files, \".dat\", sep=\"\")\nThe key for changing file names and input commands\nfrom replication to replication is to use a for loop index vari-\nable as one of the arguments of the paste() function. For\nexample, if the variable named as files in the above example\nis a for loop index representing replications, the string\nassigned to filename1 is changed from replication to replica-\ntion: \"Level1rep1.dat,\" \"Level1rep2.data,\" and so on.\nCalling system commands from R.Given a large number of\ndata and input command files, a simulation procedure for\nrunning a stand-alone software can be automated by running\nthe stand-alone software in batch mode. In batch mode, the\nsoftware can be run using some commands at the DOS\nprompt without any further manual interaction of a user.\nGagne and Furlow (2009) demonstrated how SAS can be\nused to run Mplus, LISREL, and HLM in batch mode. In\ntheir work, DOS batch files that contain some DOS com-\nmands to run those software packages in batch mode are cre-\nated and then the capability of SAS that can execute DOS\nsystem commands is used to execute those DOS batch files\nfrom SAS. In this article, the shell() function in R that can\nexecute DOS system commands from R is used to directly\nrun HLM without creating DOS batch files. For example, the\nfollowing R command runs HLM in batch mode to estimate\nparameters of a model specified in the input command file,\nwhich is rep1.hlm, using the data file \"rep1.mdm.\"\n>shell(\"hlm2 rep1.mdm rep1.hlm\")\nThe regular expression in R. Running software in batch mode\ncreates a large number of output files. To summarize simula-\ntion results, statistics of interest such as parameter estimates\nor fit indices need to be extracted from those output files. A\nregular expression is a useful tool for extracting statistics of\ninterest from output files. A regular expression is a set of lit-\neral and special characters representing a pattern that a regu-\nlar expression engine tries to match in input text. For\nexample, the regular expression \"ITEM[0-9]{4}\" matches\n[0-9] matches any single digit number and {n} matches n\noccurrence of the preceding element. Another example of the\nregular expression, which is used in this article, is the one to\nmatch a decimal number. The regular expression \"[-+]?[0-\n9]+\\\\.[0-9]+\" matches a decimal number in a text. Each com-\nponent of the previous regular expression needs to be\nexplained. In a regular expression, the square brackets [] are\nused to match any single character listed in the square brack-\nets. Therefore, [-+] matches a plus or minus sign. Since ?\nmatches the preceding element zero or more times, a decimal\nnumber without any sign is also matched by the regular\nexpression. On the other hand, in a regular expression, +\nmatches the preceding element one or more times. Therefore,\n[0-9]+ in the example matches any positive integer. Finally,\n\\\\. represents a dot in a regular expression. In all, \"[-+]?[0-\nexpression is supported by many programming languages\n(e.g., R, SAS, C++, and Java) and command line utilities in\nthe UNIX (e.g., grep, sed, and awk) because of its usefulness\nin many real world applications such as web data mining.\nThe wide applicability of the regular expression comes from\n6 SAGE Open\nits flexibility that can match a specific string. By using the\nregular expression, users can match, modify, or extract spe-\ncific strings in text files. In R, several functions support the\nregular expression. The grep() function returns indices of\nlines containing a character string that is matched by a regu-\nlar expression, which is useful in extracting only the lines\nthat are of interest from text files. For example, the following\nR command returns indices of lines that contain the string\n\"with robust standard errors\" in a text named x.\n>grep(\"with robust standard errors\", x)\nOn the other hand, the str_extract_all() function in the R\npackage stringr extracts all strings that match a pattern from\nan input vector. For example, the following R command can\nbe used to extract all decimal numbers from an input vector\nx.\n>str_extract_all(x, \"[-+]?[0-9]+ \\\\.[0-9]+\")\nBy using both grep() and str_extract_all() functions, sta-\ntistics of interest can be organized into a tabular format from\noutput files.\nHLM in batch mode. As mentioned in the previous section, a\nsimulation procedure for running HLM can be automated by\nrunning HLM in batch mode. However, a preliminary proce-\ndure is required to run HLM in batch mode because HLM\nuses its own data file format, which has .mdm (multivariate\ndata matrix) as a file extension. An mdm data file can be cre-\nated from a data file for other software packages such as\nSPSS or from an ASCII format text file, using an mdm tem-\nplate file that has .mdmt as a file extension. Given an mdm\nformat data file, HLM can be run in batch mode with an input\ncommand file (.hlm) that contains the necessary instructions\nto run HLM. Therefore, to run HLM in batch mode, an mdm\ndata file needs to be created using an mdm template file\n(.mdmt) first and then HLM can be run in batch mode using\nan mdm data file (.mdm) and input command file (.hlm). An\neasy way to create an mdm template file (.mdmt) and input\ncommand file (.hlm) is to use the graphical user interface of\nthe HLM software package. All the necessary information to\ncreate those files can be typed in the graphical user interface\nof HLM, which provides the option to create an MDM tem-\nplate file (.mdmt) and input command file (.hlm) based on\nthe information.\nExample code for a simulation using HLM. Based on the previ-\nous discussions, an R code for automating a simple simulation\nusing HLM is presented in Appendix B. This code is for gen-\nerating data sets, writing input command files, running HLM\nin batch mode, and extracting statistics of interest from output\nfiles. For a demonstration purpose, a simple two-level HLM\nwith a random intercept and slope is used: y x\n= + +\n  \n  \n= + +\nw u , and   \n= + +\nw u .\nIn the beginning of the code, the information required for\na simulation needs to be set by a user: a path for the HLM\nsoftware package, a path for a folder where all the relevant\nfiles are saved, the number of replications, the number of\ngroups, the number of subjects within each group, and\nparameter values for a simple two-level model. Once the\ninformation is typed, the remaining part of the code does not\nneed to be changed.\nGiven the information, ASCII format data files for a sim-\nple two-level model are generated. Because separate data\nfiles for each level are required to run HLM, two separate\ndata files for Level 1 and Level 2 are generated for each rep-\nlication. The write.fwf() function is used to create data files\nwith a fixed width format, which is required by HLM in cre-\nating an mdm format data file.\nAs mentioned before, HLM uses mdm data files (.mdm)\nfor an analysis. Therefore, ASCII format data files need to be\nconverted to mdm data files using mdm template files\n(.mdmt). In this example, mdm template files are created by\nusing the write() function that can write template files line by\nline. The paste() function within the write() function is used\nto change file names from replication to replication. Once\nmdm template files are prepared, mdm data files are created\nby running HLM in batch mode using the shell() function.\nSimilarly, input command files (.hlm) can be created using\nthe write() and paste() functions and HLM can be run in\nbatch mode using the shell() function with an mdm data file\n(.mdm) and input command file (.hlm) for each replication.\nGiven a large number of output files after running HLM\nin batch model, the estimated parameters need to be extracted\nfrom those output files to summarize simulation results. In\nthis example, the grep() and str_extract_all() functions that\nsupport the regular expression are used to extract the statis-\ntics of interest from output files. To simplify a code, the lap-\nply() function is used to replace the for loop statement. In the\ncode in Appendix B, outPut1 is a list object in R that contains\nthe whole contents of output files as its elements. To filter out\nonly four lines in output files that contain estimated param-\neters, the grep() function is used to create a list object out-\nPut2. The str_extract_all() function is used to extract\nestimated parameters, which are decimal numbers, from\neach line to create a tabular form of data. The results of\nparameter estimates across all replications will be saved in\nthe summary folder under the user-specified main folder.\nEstimation Options in Software Packages\nThe software packages presented in this article provide vari-\nous estimation options to handle non-normal and categorical\ndata. In conducting a Monte Carlo simulation study, it is very\nimportant to choose appropriate estimation options depend-\ning on research questions. In this section, various estimators\ndeveloped to handle non-normal and categorical data are\nbriefly discussed, and options to specify different estimators\nin the software packages are also presented.\nIn general, parameter estimates in SEM can be obtained\nby optimizing a fit function. The maximum likelihood (ML),\ngeneralized least square (GLS), and unweighted least square\n(ULS) estimators share the same fit function:\n= -\n/ ( )}\ntr[({S- ]\n)\n \n , where S , ( )\n\n , and W repre-\nsent observed covariance, model-implied covariance, and\nweight matrices, respectively (Bollen, 1989; Finney &\nDiStefano, 2006). However, the weight matrices differ across\nestimators: WML = ( )\n\n , W S\nGLS = , and W I\nULS = , where\nI represents an identity matrix. Note that the ML and GLS\nestimators require the multivariate normality assumption but\nthe ULS estimator does not. Browne (1984) showed that\naforementioned fit functions are special cases of a more gen-\neral fit function: F s s\nW\n= - -\n -\n[ [ ]\n( )] ( )\n   \n \n, where s and\n \n( )\n are the vectors of non-redundant elements of S and\n( )\n\n . Because the previous fit function can be considered as\na weighted sum of squared residuals, the estimator based on\nthe previous fit function is called the weighted least square\n(WLS) estimator. Browne (1984) also suggested using the\nweight matrix that is defined as the covariances of the\nobserved sample variances and covariances. The weight\nmatrix suggested by Browne reflects kurtosis of observed\nvariables, and therefore the estimator can correct the viola-\ntion of the normality assumption. Because this estimator\ndoes not require the multivariate normality assumption, it is\nusually called the asymptotically distributed free (ADF)\nestimator.\nDespite the theoretical merit, the ADF estimator has some\npractical limitations. The size of the weight matrix can\nincrease dramatically as the number of observed variable\nincreases. As a result, the ADF estimator is computationally\ndemanding to calculate the inversion of the weight matrix\nand therefore has the limitation in the number of observed\nvariables. Also, the ADF estimator requires a large sample\nsize for consistent and efficient estimates (Wang & Wang,\n2012). Another option to handle the non-normality without\nthe computational burden is to adjust or rescale relevant esti-\nmates from the ML estimator. Because the ML estimator is\nknown to provide relatively accurate parameter estimates\nunder the non-normality (Finch, West, & MacKinnon, 1997),\nusually the robust chi-square statistics and standard errors of\nparameter estimates are adjusted or rescaled to prevent\nincreased Type I error rates.\nFor categorical variables, the categorical variable meth-\nodology (CVM) was introduced to incorporate the metric of\nthe categorical variables into the ADF estimator (B. O.\nMuth\u00e9n, 1984). In the CVM, observed categories are related\nto the underlying latent response variable through threshold\nmodels. However, the CVM approach is still the ADF esti-\nmator and therefore shares the same limitations with the\noriginal ADF estimator. Robust WLS estimators (B. O.\nMuth\u00e9n, 1993) such as weighted least squares mean-adjusted\n(WLSM), weighted least squares mean and variance-adjusted\n(WLSMV), and diagonal weighted least squares (DWLS)\nwere developed to avoid the computational burden of the\nADF estimator by inverting the diagonal elements of the\nweight matrix instead of the full weight matrix. Also, robust\nWLS estimators provide rescaled chi-square statistics and\nstandard errors. The options that need to be specified to use\naforementioned estimators in different software packages are\npresented in Table 1.\nDiscussion\nThis article is intended to provide concrete examples of a\nMonte Carlo simulation study using some standard software\npackages in SEM. Built-in Monte Carlo simulation capabili-\nties or external software packages are used to implement\nMonte Carlo simulation studies for Mplus, LISREL, SAS\nPROC CALIS, and R package lavaan. Because of the close\nrelationship between SEM and HLM, it is also demonstrated\nhow to automate a Monte Carlo simulation study using\nHLMwin using the R software package.\nIn Mplus, generating and analyzing data sets can be done\nwithin Mplus using the MODELPOPULATION and MODEL\ncommand, respectively. The generated data sets can be saved\nas text files using REPSAVE and SAVE options in the\nMONTECARLO command. Also, external data files can be\nused to do a simulation by using the TYPE=MONTECARLO\noption in DATA command. Similarly, in LISREL, the RP\ncommand can be used to fit a model to multiple data sets in a\nsingle data file, which reports multiple results in a single out-\nput file. However, unlike Mplus, summary statistics for the\nmultiple results are not provided by the RP command. In this\narticle, the results created by the RP command are summa-\nrized using the R functions that support regular expression.\nOn the other hand, a Monte Carlo simulation using the R\nTable 1. Estimation Options in the Software Packages Used in This Study.\nEstimator Mplus LISREL PROC CALIS lavaan\nMaximum likelihood ML ML ML ML\nGeneralized least squares GLS GL GLS GLS\nUnweighted least squares ULS UL ULS ULS\nWeighted least squares WLS WL WLS WLS\nRobust weighted least squares (categorical) WLSM/WLSMV DW DWLS WLSM/WLSMV\nRobust standard error (non-normal) MLR/MLM Two-step Not applicable MLR/MLM\nNote. Estimation methods in Mplus, LISREL, PROC CALIS, and lavaan can be specified in the ESTIMATOR=, ME=, METHOD=, and ESTIMATOR= options,\nrespectively.\n8 SAGE Open\npackage lavaan can be greatly simplified by using the R pack-\nage simsem. The bind(), model(), and sim() functions in the R\npackage simsem can be used to specify population parame-\nters, generate data sets, and fit a model to the data sets. The\ngenerated data sets in the R package simsem can be exported\nto the external data files for Mplus or LISREL. The BY state-\nment in SAS PROC CALIS is similar to the RP command in\nLISREL in that it can be used to do separate analyses on\nobservations in groups defined by the variables in the BY\nstatement. Combined with the BY statement, the ODS output\nstatement in SAS PROC CALIS can be used to create a SAS\ndata set containing results across all replications.\nTo the author's knowledge, neither internal capabilities\nnor external software packages for a Monte Carlo simulation\nstudy exist for a simulation using HLMwin. In such a case,\nsome built-in functions in R can be used to automate a simu-\nlation using HLMwin. The write() and paste() functions in R\ncan be used to write input command files for HLMwin.\nGiven input command files, HLMwin can be run in batch\nmode using the shell() function that can execute DOS system\ncommands from R. To summarize, output files, grep(), and\nstr_extract_all() functions supporting regular expressions\ncan be used to extract statistics of interest from output files.\nThe regular expression is a powerful tool for extracting spe-\ncific strings from input text files and could be used in extract-\ning and summarizing results from output files of any software\npackages. The R codes presented in the appendices are just\nsimple examples of using those R functions. It is hoped that\nthe code could provide some building blocks for researchers\nto write their own code to automate simulation procedures.\nAppendix A\nCodes for a Simulation Using Mplus\nA1. Mplus code for a simulation using data sets generated by Mplus itself\nsimple two factors CFA with six indicators.\ndata sets are generated using Mplus itself.\nrepsave = all;  ! save data files for all replications\nsave = sim*.dat;  ! saved file names: sim1.dat,sim2.dat,etc.\n! simlist.dat containing the list of data file names will be\n! also generated and will be used in a simulation using\n! SAS PROC CALIS in Appendix E.\nMODEL POPULATION:  ! model specification for data generation\ny1-y6@1;  ! @ = for fixed parameter\nMODEL: ! model specification for data analysis\nA2. Mplus code for a simulation using data sets generated outside Mplus\nsimple two factors CFA with six indicators.\ndata sets are generated outside Mplus.\nfile = simMplus.dat; ! list of external data file names\n! for this example, external data files are generated by\n! R package simsem in Appendix C.\ntype = montecarlo;\nMODEL: ! model specification for data analysis\nAppendix B\nR Codes for a Simulation Using HLM\n#########################################################################\n# R codes for automating a Monte Carlo simulation using HLM\n#- written by: AUTHOR (Ph.D.)\n# - the purpose of this code is to show how R package can be used\n#  to automate A Monte Carlo simulation using HLM software.\n#  in this code,\n#  1. text files containing simulation data will be generated\n# using simple two level equation.\n# 2. .mdmt files (mdm template file) will be created to convert\n# text files to .mdm files (mdm data file for HLM).\n# 3. shell() function in R is used to run HLM in batch mode\n#  to convert text files to .mdm files using .mdmt files.\n# 4. .hlm files (input command files) will be created to run HLM\n# 5. shell() function in R is used to run HLM in batch mode\n#  to estimate parameters using .HLM files.\n#  6. from output files, parameter estimates of interest are\n#  extracted using the functions in R that support regular\n# expression.\n# - usage\n# 1. this script require two R packages. please install\n#  `gdata' and `stringr' packages before running this code.\n# 2. then CHANGE SETTINGS in \"simulation setting\" section below.\n#  3. then select the whole code and run. all the relevant files\n#  and summarized results will be saved under the `mainfolder'\n#  that is specified by a user in the \"simulation setting\" .\n#########################################################################\n#########################################################################\n### simulation setting ###\n#########################################################################\n# simulation setting\n# all generated data, input commands, and results\n# will be saved in the main folder specified by a user\nmainfolder <- \"C:/hlm_example\"\nHLM2Path <- \"C:\\\\Progra~1\\\\hlm6\\\\\" # path for HLM software\nnReplications <- 10  # # of replications\nnSubWithinGroup <- 100  # # of subjects within each group\n# # of groups\n# model parameters setting\n# in this example, data were generated based\n# on the following equation:\n#########################################################################\n# load library\nlibrary(gdata)  # to use write.fwf()\nlibrary(stringr)  # to use str_extract_all()\n# create directories\ndir.create(file.path(mainfolder))\ndir.create(file.path(mainfolder,\"data\"))\ndir.create(file.path(mainfolder,\"summary\"))\n# check working directory\nsetwd(mainfolder)\ngetwd()\n#########################################################################\n### generating data set using multilevel equation ###\n#########################################################################\nfor (files in 1:nReplications) {\n # generating Level 1 data\n dataLevel1 <- mat.or.vec(nGroup*nSubWithinGroup,4)\n colnames(dataLevel1) <- c(\"Group\",\"X\",\"W\",\"Y\")\n rowIndex <- 0\n for (group in 1:nGroup) {\n for (sub in 1:nSubWithinGroup) {\n rowIndex <- rowIndex + 1\ndataLevel1[rowIndex,] <- c(group,x,w,y)\n}\n}\n # generating Level 2 data\n dataLevel2 <- unique(dataLevel1[ ,c(\"Group\",\"W\")])\n filename1 <- paste(\"Level1rep\",files,\".dat\",sep=\"\")\n # write.fwf() is used to export data using fixed width format\n formatInfoL1 <- write.fwf(data.frame(round(dataLevel1,4)),sep=\"\",\nfile=file.path(mainfolder,\"data\",filename1)\n,colnames=FALSE,formatInfo=TRUE)\n filename2 <- paste(\"Level2rep\",files,\".dat\",sep=\"\")\n formatInfoL2 <- write.fwf(data.frame(round(dataLevel2,4)),sep=\"\"\n,file=file.path(mainfolder,\"data\",filename2)\n,colnames=FALSE,formatInfo=TRUE)\n}\n#########################################################################\n### creating .mdmt file to convert ASCII files to .mdm ###\n#########################################################################\n# write() function is used to write each line of .mdmt file.\n# append = TRUE is used to append a line to a file\nfor (rep in 1:nReplications) {\n # .mdmt file names would be rep1.mdmt, rep2.mdmt, etc.\n mdmtFile <- paste(\"rep\",rep,\".mdmt\",sep=\"\")\n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"growthmodel:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"rawdattype:ascii\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(paste(\"l1fname:\",file.path(mainfolder,\"data\")\n,\"/Level1rep\",rep,\".dat\",sep=\"\")\n,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(paste(\"l2fname:\",file.path(mainfolder,\"data\")\n,\"/Level2rep\",rep,\".dat\",sep=\"\")\n,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"numl1var:3\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"numl2var:1\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"l1missing:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(paste(\"mdmname:rep\",rep,\".mdm\",sep=\"\") \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"*begin l1vars\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"X\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"W\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"Y\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"*end l1vars\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"*begin l2vars\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"W\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"*end l2vars\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n}\n#########################################################################\n### run HLM in batch mode to convert .txt to .mdm ###\n#########################################################################\nsetwd(file.path(mainfolder,\"data\"))\nfor (rep in 1:nReplications) {\n shell(paste(HLM2Path,\"hlm2\",\" -R rep\",rep,\".mdmt\",sep=\"\"))\n}\n#########################################################################\n### creating .hlm file to run HLM ###\n#########################################################################\nfor (rep in 1:nReplications) {\n mdmtFile <- paste(\"rep\",rep,\".hlm\",sep=\"\")\n write(paste(\"#WHLM CMD FILE FOR \",file.path(mainfolder,\"data\",\"rep\")\n,rep,\".mdm\",sep=\"\") \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"nonlin:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"level1:Y=INTRCPT1+X+RANDOM\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"level2:INTRCPT1=INTRCPT2+W+random/\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"level2:X=INTRCPT2+W+random/\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"fixtau:3\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"accel:5\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"level1weight:none\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"level2weight:none\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"varianceknown:none\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"hypoth:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"resfil1:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"resfil2:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"homvar:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"constrain:N\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"heterol1var:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\nwrite(gsub(\"/\",\"\\\\\\\\\",paste(\"graphgammas:\",file.path(mainfolder,\"data\" ,\"graphrep\"),rep,\".geq\",sep=\"\")) \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"lvr:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"title:no title\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n\nwrite(gsub(\"/\",\"\\\\\\\\\",paste(\"output:\",file.path(mainfolder,\"data\" ,\"outputrep\"),rep,\".txt\",sep=\"\")) \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"fulloutput:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n write(\"mlf:n\" \n ,file=file.path(mainfolder,\"data\",mdmtFile), append=T)\n}\n#########################################################################\n###  run HLM in batch mode to estimate parameters using .HLM  ###\n#########################################################################\nsetwd(file.path(mainfolder,\"data\"))\nfor (rep in 1:nReplications) {\n shell(paste(HLM2Path,\"hlm2 \",\"rep\",rep,\".mdm \",\"rep\",rep,\".hlm\",sep=\"\"))\n}\n#########################################################################\n### summarize estimates of interest from output files ###\n#########################################################################\n# list.files() will list the names of files containing .txt\n# readLines() will read each file line by line\n# lapply() is used to replcace for loop statement, which makes a code simple\n# outPut1 is a list in R of which element are the content of each output file\noutPut1 <- lapply(list.files(pattern=\".txt\"),readLines)\n# grep() will returns indices of lines containing a character string\n# that is matched by a regular expression.\n# in this code, only the portion of each output file (from 6th to 10th line\n# after \"with robust standard errors\") will be extracted.\n# outPut2 contains only portion of output files\noutPut2 <- lapply(outPut1, function(x) x[(grep(\"with robust standard errors\",x)+6):(grep(\"with robust standard\n# remove unnecessary line 3 from outPut2\noutPut3 <- lapply(outPut2, function(x) x[-3])\n# \"[0-9]+\\\\.[0-9]+\" = regular expression representing decimal numbers\n# str_extract_all() will extract only decimal numbers from outPut3\noutPut4 <- lapply(outPut3, function(x) str_extract_all(x,\"[0-9]+\\\\.[0-9]+\"))\n# organize outPut4 to be matrix form using do.call()\noutPut5 <- lapply(outPut4, function(x) do.call(\"rbind\",x))\n# combine all matrix form of results into one\noutPut6 <- do.call(\"rbind\",outPut5)\n# put column and row names\ncolnames(outPut6) <- c(\"Coefficient\",\"SE\",\"T-ratio\",\"P-value\")\n# final results will be save in \"mainfolder/summary/results.txt\"\nwrite.table(outPut6,file=file.path(mainfolder,\"summary\",\"results.txt\"),quote=F)\nAppendix C\nR Codes for a Simulation Using R Package simsem and lavaan\n# simple two factors CFA with six indicators\nlibrary(simsem) # load simsem libary\n# define LY = factor loading matrix\nloading <- matrix(0, 6, 2) # define 6 by 2 loading matrix with zeros\nloading[1:3, 1] <- NA # NA = free parameter to be estimated\nloading[4:6, 2] <- NA # 0 = fixed to zero\nloadingValues <- matrix(0, 6, 2) # define population factor loadings\nLY <- bind(loading, loadingValues) # create LY using bind()\n# define PS = residual variance-covariance matrix among factors\nlatentCov <- matrix(NA, 2, 2) # 2 by 2 matrix, NA = free parameter\ndiag(latentCov) <- 1 # variances two factors are fixed to 1\nPS <- binds(latentCov,0)  # create PS using bind()\n# population covariance of factors = 0\n# define TE = measurement error variance-covariance among indicators\nTE <- binds(diag(6))  # residual variances of indicators = 1\n# create templates for data generation and analysis using model()\nCFA.Model <- model(LY = LY, PS = PS, TE = TE, modelType = \"CFA\")\n# run a Monte Carlo simulation with 100 replications\nsummary(output)\n# export generated data sets with Mplus data format.\n# program=\"LISREL\" will export data with LISREL data format.\n# this code will generate 100 data files with Mplus format.\n# data file names: simMplus1.dat, simMplus2.dat, etc.\n# simMplus.dat that contains data file names will also generated.\n# simMplus.dat can be used for a Mplus simulation in Appendix A2.\nexportData(nRep=100, model=CFA.Model, fileStem = \"simMplus\",n=500, program=\"Mplus\")\n# simLISREL.dat contains the whole data sets in one file.\n# simLISREL.dat can be used for a LISREL simulation in Appendix D.\nexportData(nRep=100, model=CFA.Model, fileStem = \"simLISREL\"\nAppendix D\nRA = `simLISREL.dat'\nOU ND=3 PV=simLISREL.par SV=simLISREL.se\nAppendix E\nCodes for a Simulation Using SAS PROC CALIS\nE1. R code to combine separate data files generated from Mplus for SAS PROC CALIS\n# read file names from simlist.dat, which is generated by the Mplus code\n# in Appendix A1.\nfiles <- readLines(\"simlist.dat\")\n# read actual data files using file names from simlist.dat\ndataSets <- lapply(files, function(x) cbind(read.table(x),x))\n# merge separate data files into one big data file\ndataSets2 <- data.frame(do.call(\"rbind\",dataSets))\n# give column names\n# write csv file for SAS PROC CALIS\nwrite.csv(dataSets2,\"dataForSAS.csv\",row.names=FALSE)\nE2. SAS code for a simulation\n/* import data file generated in Appendix E1 */\nproc import datafile=\"C:\\semSAS\\dataForSAS.csv\"\n out=dataForSAS dbms=csv replace;\ngetnames=yes;\nrun;\n/* data need to be sorted according to `by' */\nproc sort data=dataForSAS;\nby rep;\nrun;\nproc calis data=dataForSAS method=ml;\nlineqs\nstd\ncov\n /* by statement is used to perform separate analysis */\n /* on observations in group defined by the variables */\n /* in the by statement. */\nby rep;\n /* ods statement can be used to summarize results of */\n /* separate analysis */\nods output ParameterEstimatesStart=parms;\nrun;\nDeclaration of Conflicting Interests\nThe author(s) declared no potential conflicts of interest with respect\nto the research, authorship, and/or publication of this article.\nFunding\nThe author(s) received no financial support for the research and/or\nauthorship of this article.\nReferences\nBandalos, D. L. (2006). The use of Monte Carlo studies in struc-\ntural equation modeling research. In G. R. Hancock & R. O.\nMueller (Eds.), Structural equation modeling: A second course\nBollen, K. A. (1989). Structural equations with latent variables.\nNew York, NY: Wiley.\nBrowne, M. W. (1984). Asymptotically distribution free methods\nfor the analysis of covariance structures. British Journal of\nCohen, A. S., Kane, M. T., & Kim, S. H. (2001). The precision of\nsimulation study results. Applied Psychological Measurement,\nCurran, P. J. (2003). Have multilevel models been structural equa-\ntion models all along? Multivariate Behavioral Research, 38,\nEnders, C. K., & Bandalos, D. L. (2001). The relative performance\nof full information maximum likelihood estimation for miss-\ning data in structural equation models. Structural Equation\nFan, X., & Fan, X. (2005). TEACHER'S CORNER: Using SAS for\nMonte Carlo Simulation Research in SEM. Structural Equation\nFinch, J. F., West, S. G., & MacKinnon, D. P. (1997). Effects\nof sample size and nonnormality on the estimation of medi-\nated effects in latent variable models. Structural Equation\nFinney, S. J., & DiStefano, C. (2006). Non-normal and categorical\ndata in structural equation modeling. In G. R. Hancock & R. O.\nMueller (Eds.), Structural equation modeling: A second course\nGagne, P., & Furlow, C. F. (2009). Automating multiple software\npackages in simulation research for structural equation mod-\neling and hierarchical linear modeling. Structural Equation\nHarwell, M. R., Stone, C. A., Hsu, T.-C., & Kirisci, L. (1996). Monte\nCarlo studies in item response theory. Applied Psychological\nHox, J. J. (2013). Multilevel regression and multilevel structural\nequation modeling. In T. D. Little (Ed.), Oxford handbook\nUniversity Press.\nJ\u00f6reskog, K. G., & S\u00f6rbom, D. (2006). LISREL 8.8 for Windows\n[Computersoftware].Skokie,IL:ScientificSoftwareInternational.\nMehta, P. D., & Neale, M. C. (2005). People are variables too:\nMultilevel structural equations modeling. Psychological\nMuth\u00e9n, B. O. (1984). A general structural equation model with\ndichotomous, ordered categorical, and continuous latent vari-\nMuth\u00e9n, B. O. (1993). Goodness of fit with categorical and other\nnonnormal variables. In K. A. Bollen & J. S. Long (Eds.),\nPark, CA: SAGE.\n(7th ed.). Los Angeles, CA: Author.\nNarayanan, A. (2012). A review of eight software packages for\nstructural equation modeling. The American Statistician, 66,\nPaxton, P., Curran, P. J., Bollen, K., Kirby, J., & Chen, F. (2001).\nMonte Carlo experiments: Design and implementation.\nPornprasertmanit, S., Miller, P., & Schoemann, A. (2013). sim-\nsem: SIMulated Structural Equation Modeling. Retrieved from\nhttp://cran.r-project.org/web/packages/simsem/index.html\nRaudenbush, S. W., Bryk, A. S., & Congdon, R. (2004). HLM 6\nfor Windows [Computer software]. Skokie, IL: Scientific\nSoftware International.\nR Core Team. (2012). R: A language and environment for statisti-\ncal computing. Vienna, Austria: R Foundation for Statistical\nComputing. Available from http://www.R-project.org/\nRosseel, Y. (2012). lavaan: An R package for structural equa-\ntion modeling. Journal of Statistical Software, 48(2), 1-36.\nRetrieved from http://www.jstatsoft.org/v48/i02/\nWang, J., & Wang, X. (2012). Structural equation modeling:\nApplications using Mplus. West Sussex, UK: John Wiley.\nWest, B. T., & Galecki, A. T. (2011). An overview of current soft-\nware procedures for fitting linear mixed models. The American\nAuthor Biography\nSunbok Lee received Ph.D. in Educational Psychology with\nQuantitative Methods major from the University of Georgia.\nCurrently, the author is working as a postdoctoral researcher at the\nCenter for Family Research in the Univeristy of Georgia."
}